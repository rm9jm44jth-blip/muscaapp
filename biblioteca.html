<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Biblioteca - M√∫sica Pro</title>

    <!-- Estilos modernizados Glass ultra premium -->
    <style>
        :root {
            --primary-1: #ff375f;
            --primary-2: #ff9f0a;
            --glass-bg: rgba(255, 255, 255, 0.12);
            --glass-bg-hover: rgba(255, 255, 255, 0.18);
            --glass-border: rgba(255, 255, 255, 0.25);
            --card-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
            --gradient: linear-gradient(135deg, var(--primary-1), var(--primary-2));
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* NAVBAR */
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 22px 40px;
            position: sticky;
            top: 0;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(30px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .logo {
            font-size: 32px;
            font-weight: 900;
            background: var(--gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .nav-links {
            display: flex;
            gap: 28px;
        }

        .nav-links a {
            padding: 10px 22px;
            border-radius: 100px;
            font-size: 16px;
            text-decoration: none;
            color: #fff;
            opacity: 0.8;
            transition: 0.25s;
        }

        .nav-links a:hover,
        .nav-links a.active {
            background: var(--glass-bg);
            opacity: 1;
        }

        /* HEADER */
        .library-header {
            padding: 60px 40px 40px;
            background: linear-gradient(135deg, rgba(255, 55, 95, 0.15), rgba(255, 159, 10, 0.15));
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .library-header h1 {
            font-size: 54px;
            font-weight: 800;
            margin-bottom: 20px;
        }

        .stats {
            opacity: 0.85;
            display: flex;
            gap: 32px;
            font-size: 19px;
        }

        /* SEARCH */
        .search-container {
            padding: 25px 40px;
            position: sticky;
            top: 80px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(25px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1500;
        }

        .search-bar {
            width: 100%;
            max-width: 650px;
            padding: 18px 28px;
            border-radius: 100px;
            font-size: 18px;
            background: var(--glass-bg);
            border: 2px solid var(--glass-border);
            color: #fff;
            transition: 0.25s;
        }

        .search-bar:focus {
            outline: none;
            border-color: var(--primary-1);
            background: var(--glass-bg-hover);
        }

        /* CONTROLS */
        .controls {
            padding: 30px 40px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-btn {
            padding: 14px 26px;
            border-radius: 100px;
            border: none;
            background: var(--glass-bg);
            color: #fff;
            font-size: 16.5px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: 0.25s;
        }

        .control-btn:hover {
            background: var(--glass-bg-hover);
        }

        .control-btn.primary {
            background: var(--gradient);
            font-weight: 600;
        }

        .control-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 55, 95, 0.35);
        }

        /* GRID */
        .music-grid {
            padding: 40px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 28px;
        }

        .music-item {
            background: var(--glass-bg);
            border-radius: 22px;
            padding: 24px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(25px);
            transition: 0.25s;
            cursor: pointer;
        }

        .music-item:hover {
            transform: translateY(-5px);
            background: var(--glass-bg-hover);
            box-shadow: var(--card-shadow);
        }

        .album-art {
            width: 100%;
            aspect-ratio: 1/1;
            border-radius: 18px;
            background: var(--gradient);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 56px;
            margin-bottom: 18px;
            position: relative;
        }

        .play-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            font-size: 40px;
            transition: 0.25s;
        }

        .music-item:hover .play-overlay {
            opacity: 1;
        }

        .music-info {
            text-align: center;
        }
        .music-title {
            font-weight: 600;
            font-size: 17px;
            margin-bottom: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .music-artist {
            opacity: 0.65;
            font-size: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* UPLOAD */
        .upload-area {
            margin: 40px;
            padding: 60px;
            border: 3px dashed var(--glass-border);
            border-radius: 30px;
            text-align: center;
            transition: 0.25s;
            cursor: pointer;
        }

        .upload-area:hover,
        .upload-area.dragover {
            background: rgba(255, 55, 95, 0.08);
            border-color: var(--primary-1);
            transform: scale(1.01);
        }

        .upload-icon {
            font-size: 72px;
            opacity: 0.5;
            margin-bottom: 25px;
        }

        /* MODAL */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(30px);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-content {
            background: var(--glass-bg);
            backdrop-filter: blur(40px);
            border-radius: 30px;
            padding: 50px;
            max-width: 900px;
            width: 100%;
            border: 1px solid var(--glass-border);
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: none;
            background: var(--glass-bg);
            color: #fff;
            font-size: 26px;
            cursor: pointer;
            transition: 0.25s;
        }

        .modal-close:hover {
            background: var(--glass-bg-hover);
            transform: rotate(90deg);
        }

        /* TOAST */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 18px 28px;
            backdrop-filter: blur(25px);
            border-radius: 14px;
            font-weight: 600;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(40px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

    </style>
</head>
<body>
    <!-- NAV -->
    <nav>
        <div class="logo">M√∫sica Pro</div>
        <div class="nav-links">
            <a href="index.html">Inicio</a>
            <a class="active" href="biblioteca.html">Biblioteca</a>
            <a href="reproductor.html">Reproductor</a>
            <a href="playlists.html">Playlists</a>
        </div>
    </nav>

    <!-- HEADER -->
    <header class="library-header">
        <h1>Tu Biblioteca</h1>
        <div class="stats">
            <span id="totalSongs">0 canciones</span>
            <span id="totalArtists">0 artistas</span>
            <span id="totalDuration">0 min</span>
        </div>
    </header>

    <!-- SEARCH -->
    <div class="search-container">
        <input id="searchInput" class="search-bar" type="text" placeholder="Buscar canciones, artistas, √°lbumes..." />
    </div>

    <!-- CONTROLES -->
    <div class="controls">
        <button class="control-btn primary" id="addMusicBtn">‚ûï Agregar M√∫sica</button>
        <button class="control-btn" id="sortBtn">‚áÖ Ordenar</button>
        <button class="control-btn" id="filterBtn">‚öôÔ∏è Filtros</button>
        <button class="control-btn" id="refreshBtn">üîÑ Actualizar</button>
    </div>

    <input type="file" id="fileInput" style="display:none;" accept="audio/*" multiple />

    <!-- UPLOAD -->
    <div id="uploadArea" class="upload-area">
        <div class="upload-icon">üéµ</div>
        <div class="upload-text">Arrastra tu m√∫sica aqu√≠</div>
        <div class="upload-subtext">o haz clic para seleccionar archivos</div>
    </div>

    <!-- GRID -->
    <div id="musicGrid" class="music-grid"></div>

    <!-- MODAL -->
    <div id="musicModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">√ó</button>
            <div id="modalContent"></div>
        </div>
    </div>

    <!-- TOAST -->
    <div id="toast" class="toast"></div>

    <!-- SCRIPTS (MEJORADOS) -->
    <script>
/*
 * M√∫sica Pro - Biblioteca (JS robusto y garantizado local-first)
 * - Siempre local: obliga a usar archivos locales (carpeta seleccionada o IDB)
 * - Mini-cuenta local (token UUID) guardada en IndexedDB/meta
 * - Detecci√≥n autom√°tica de carpeta si hay permisos
 * - Escaneo fiable de carpeta (File System Access API) y fallback a IDB
 * - Si no hay nada, la app insiste en elegir carpeta o agregar archivos
 */

let db = null;
let currentTracks = [];
let directoryHandle = null; // FileSystemDirectoryHandle

// ---------- Helpers ----------
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function escapeHtml(text) {
  return String(text || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

function showToast(msg, t = 3000) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(el._timer);
  el._timer = setTimeout(() => el.style.display = 'none', t);
}

// ---------- IndexedDB: open and meta helpers ----------
function openDB() {
  return new Promise((resolve, reject) => {
    try {
      const req = indexedDB.open('MusicProDB', 3);
      req.onupgradeneeded = (e) => {
        const idb = e.target.result;
        if (!idb.objectStoreNames.contains('music')) {
          const store = idb.createObjectStore('music', { keyPath: 'id', autoIncrement: true });
          store.createIndex('title', 'title', { unique: false });
        }
        if (!idb.objectStoreNames.contains('meta')) {
          idb.createObjectStore('meta', { keyPath: 'key' });
        }
      };
      req.onsuccess = (e) => { db = e.target.result; resolve(db); };
      req.onerror = (e) => reject(e.target.error);
    } catch (err) { reject(err); }
  });
}

function metaPut(key, value) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['meta'], 'readwrite');
    const store = tx.objectStore('meta');
    const req = store.put({ key, value });
    req.onsuccess = () => res();
    req.onerror = (e) => rej(e.target.error);
  });
}

function metaGet(key) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['meta'], 'readonly');
    const store = tx.objectStore('meta');
    const req = store.get(key);
    req.onsuccess = () => res(req.result ? req.result.value : undefined);
    req.onerror = (e) => rej(e.target.error);
  });
}

// Blob storage in meta (fallback)
function saveBlobInMeta(blob) {
  return new Promise((res, rej) => {
    const key = `blob:${Date.now()}:${Math.random().toString(36).slice(2,8)}`;
    const tx = db.transaction(['meta'], 'readwrite');
    const store = tx.objectStore('meta');
    const req = store.put({ key, value: blob });
    req.onsuccess = () => res(key);
    req.onerror = (e) => rej(e.target.error);
  });
}

function readBlobFromMeta(key) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['meta'], 'readonly');
    const store = tx.objectStore('meta');
    const req = store.get(key);
    req.onsuccess = () => res(req.result ? req.result.value : null);
    req.onerror = (e) => rej(e.target.error);
  });
}

// ---------- File System Access: request directory and scan ----------
async function requestDirectoryAccess(force = false) {
  if (!('showDirectoryPicker' in window)) return false;
  try {
    // if already have saved handle, try to restore
    if (!force) {
      const saved = await metaGet('directoryHandle');
      if (saved) {
        try {
          directoryHandle = saved;
          // test permission
          const perm = await directoryHandle.requestPermission({ mode: 'readwrite' });
          if (perm === 'granted') return true;
        } catch (err) {
          directoryHandle = null; // continuar√° a pedir de nuevo
        }
      }
    }

    directoryHandle = await window.showDirectoryPicker();
    const permission = await directoryHandle.requestPermission({ mode: 'readwrite' });
    if (permission === 'granted') {
      try { await metaPut('directoryHandle', directoryHandle); } catch (e) { console.warn('No se pudo guardar handle'); }
      return true;
    }
    return false;
  } catch (err) {
    console.warn('requestDirectoryAccess error', err);
    return false;
  }
}

async function scanDirectoryForAudio(handle) {
  const tracks = [];
  // Recorrer directorio (no recursivo profundo para simplicidad; recursivo opcional)
  for await (const entry of handle.values()) {
    try {
      if (entry.kind === 'file') {
        const name = entry.name;
        if (/\.(mp3|wav|ogg|m4a|flac|aac)$/i.test(name)) {
          const file = await entry.getFile();
          const duration = await getAudioDuration(file);
          const parts = name.replace(/\.[^/.]+$/, '').split(' - ');
          let artist = 'Artista desconocido', title = parts.join(' - ');
          if (parts.length >= 2) { artist = parts[0].trim(); title = parts.slice(1).join(' - ').trim(); }
          tracks.push({
            title, artist, fileName: name, fileSize: file.size, fileType: file.type || 'audio/*',
            duration: Math.floor(duration)||0, dateAdded: new Date().toISOString(), storage: 'fs', fileHandleName: name
          });
        }
      }
    } catch (err) { console.warn('scan entry error', err); }
  }
  return tracks;
}

// ---------- Music store operations ----------
function addTrackToDB(track) {
  return new Promise((res, rej) => {
    const tx = db.transaction(['music'], 'readwrite');
    const store = tx.objectStore('music');
    const req = store.add(track);
    req.onsuccess = () => res(req.result);
    req.onerror = (e) => rej(e.target.error);
  });
}

function getAllTracksFromDB() {
  return new Promise((res, rej) => {
    const tx = db.transaction(['music'], 'readonly');
    const store = tx.objectStore('music');
    const req = store.getAll();
    req.onsuccess = () => res(req.result || []);
    req.onerror = (e) => rej(e.target.error);
  });
}

async function clearAndPopulateFromDirectory() {
  // Limpia DB y vuelve a poblar desde directorio para garantizar que siempre refleje la carpeta local
  try {
    const tx = db.transaction(['music'], 'readwrite');
    const store = tx.objectStore('music');
    // eliminar todo (simple y eficiente)
    store.clear();
    await new Promise(r => tx.oncomplete = r);

    const scanned = await scanDirectoryForAudio(directoryHandle);
    for (const s of scanned) {
      await addTrackToDB(s);
    }
    return scanned;
  } catch (err) { console.error(err); return [];} 
}

// ---------- Audio helpers ----------
function getAudioDuration(file) {
  return new Promise((resolve) => {
    const url = URL.createObjectURL(file);
    const audio = new Audio();
    audio.src = url;
    audio.addEventListener('loadedmetadata', () => { resolve(audio.duration || 0); URL.revokeObjectURL(url); });
    audio.addEventListener('error', () => { resolve(0); URL.revokeObjectURL(url); });
  });
}

function dataURLtoBlob(dataurl) {
  const arr = dataurl.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length; const u8 = new Uint8Array(n);
  while (n--) u8[n] = bstr.charCodeAt(n);
  return new Blob([u8], { type: mime });
}

// ---------- Play / export / delete ----------
async function playTrack(track) {
  try {
    let blob = null;
    if (track.storage === 'fs' && directoryHandle) {
      try {
        const fh = await directoryHandle.getFileHandle(track.fileHandleName);
        blob = await fh.getFile();
      } catch (err) { console.warn('No se pudo leer desde FS', err); }
    }
    if (!blob && track.blobKey) blob = await readBlobFromMeta(track.blobKey);
    if (!blob && track.url) blob = dataURLtoBlob(track.url);
    if (!blob) return showToast('No disponible localmente');

    const url = URL.createObjectURL(blob);
    localStorage.setItem('currentTrackBlobUrl', url);
    localStorage.setItem('currentTrack', JSON.stringify(track));
    window.location.href = 'reproductor.html';
  } catch (err) { console.error(err); showToast('Error reproduciendo'); }
}

async function exportTrack(id) {
  const all = await getAllTracksFromDB();
  const t = all.find(x => Number(x.id) === Number(id));
  if (!t) return showToast('No encontrado');
  let blob = null;
  if (t.storage === 'fs' && directoryHandle) {
    try { const fh = await directoryHandle.getFileHandle(t.fileHandleName); blob = await fh.getFile(); } catch(e){console.warn(e);} }
  if (!blob && t.blobKey) blob = await readBlobFromMeta(t.blobKey);
  if (!blob) return showToast('No se puede exportar');

  try {
    if ('showSaveFilePicker' in window) {
      const handle = await window.showSaveFilePicker({ suggestedName: t.fileName });
      const w = await handle.createWritable(); await w.write(blob); await w.close();
      showToast('Guardado correctamente');
      return;
    }
  } catch (err) { console.warn(err); }

  // fallback descarga
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url; a.download = t.fileName; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  showToast('Descarga iniciada');
}

async function removeTrack(id) {
  const tx = db.transaction(['music'], 'readwrite');
  const store = tx.objectStore('music');
  store.delete(Number(id));
  await new Promise(r => tx.oncomplete = r);
  await loadMusic();
  closeModal();
  showToast('Eliminado');
}

// ---------- File input & drop handlers ----------
const fileInput = document.getElementById('fileInput');
fileInput.addEventListener('change', async (e) => { await importFiles(Array.from(e.target.files)); fileInput.value = ''; });
document.getElementById('uploadArea').addEventListener('click', () => fileInput.click());

async function importFiles(files) {
  if (!files || files.length === 0) return;
  const audioFiles = files.filter(f => f.type && f.type.startsWith('audio/'));
  if (audioFiles.length === 0) return showToast('No hay archivos de audio');

  // intentar guardar en carpeta si existe
  let haveDir = !!directoryHandle;
  if (!haveDir && 'showDirectoryPicker' in window) {
    const r = confirm('¬øDeseas seleccionar una carpeta para guardar autom√°ticamente tus archivos? (Recomendado)');
    if (r) haveDir = await requestDirectoryAccess();
  }

  let processed = 0;
  for (const file of audioFiles) {
    try {
      const dur = await getAudioDuration(file);
      const nameNoExt = file.name.replace(/\.[^/.]+$/, '');
      const parts = nameNoExt.split(' - ');
      let artist = 'Artista desconocido', title = nameNoExt;
      if (parts.length>=2) { artist=parts[0].trim(); title=parts.slice(1).join(' - ').trim(); }

      let storage = 'idb', blobKey = null, fileHandleName = null;
      if (haveDir && directoryHandle) {
        try {
          const fh = await directoryHandle.getFileHandle(file.name, { create: true });
          const w = await fh.createWritable(); await w.write(file); await w.close();
          storage = 'fs'; fileHandleName = file.name;
        } catch (err) { console.warn('Guardar en carpeta fall√≥', err); storage='idb'; }
      }

      if (storage === 'idb') blobKey = await saveBlobInMeta(file);

      const track = { title, artist, fileName: file.name, fileSize: file.size, fileType: file.type, duration: Math.floor(dur)||0, dateAdded: new Date().toISOString(), storage, blobKey, fileHandleName };
      await addTrackToDB(track);
      processed++; showToast(`Procesado ${processed}/${audioFiles.length}`);
    } catch (err) { console.error(err); showToast('Error importando'); }
  }

  await loadMusic();
  showToast(`${processed} canci√≥n(es) agregadas`);
}

// Drag & drop
function preventDefault(e){ e.preventDefault(); e.stopPropagation(); }
['dragenter','dragover','dragleave','drop'].forEach(evt => { document.addEventListener(evt, preventDefault, false); });
const uploader = document.getElementById('uploadArea');
uploader.addEventListener('dragover', () => uploader.classList.add('dragover'));
uploader.addEventListener('dragleave', () => uploader.classList.remove('dragover'));
uploader.addEventListener('drop', async (e) => { uploader.classList.remove('dragover'); await importFiles(Array.from(e.dataTransfer.files)); });

// ---------- Render UI ----------
function renderMusicGrid(tracks) {
  currentTracks = tracks;
  const grid = document.getElementById('musicGrid');
  if (!tracks || tracks.length===0) {
    grid.innerHTML = `
      <div style="grid-column:1/-1;text-align:center;padding:80px 20px;opacity:0.9;">
        <div style="font-size:72px;opacity:0.25;margin-bottom:20px;">üéµ</div>
        <div style="font-size:22px;margin-bottom:10px;">Tu biblioteca est√° vac√≠a</div>
        <div style="opacity:0.7;margin-bottom:20px;max-width:560px;margin-left:auto;margin-right:auto;">Selecciona una carpeta local o agrega archivos para que la app funcione. La app s√≥lo funciona con archivos locales.</div>
        <div style="display:flex;gap:12px;justify-content:center;margin-top:18px;">
          <button class="control-btn primary" onclick="document.getElementById('fileInput').click()">‚ûï Agregar M√∫sica</button>
          <button class="control-btn" onclick="requestDirectoryAccess(true)">üìÅ Seleccionar Carpeta</button>
        </div>
      </div>
    `; return;
  }

  grid.innerHTML = '';
  for (const track of tracks) {
    const item = document.createElement('div'); item.className='music-item'; item.dataset.id = track.id;
    const first = track.title ? track.title.charAt(0).toUpperCase() : '‚ô´';
    item.innerHTML = `
      <div class="album-art"><div>${first}</div><div class="play-overlay">‚ñ∂</div></div>
      <div class="music-info"><div class="music-title">${escapeHtml(track.title||'Sin t√≠tulo')}</div><div class="music-artist">${escapeHtml(track.artist||'Artista desconocido')}</div></div>
    `;
    item.addEventListener('click', (e)=>{ if (e.target.closest('.play-overlay')) playTrack(track); else showTrackDetails(track); });
    item.addEventListener('dblclick', ()=>playTrack(track));
    grid.appendChild(item);
  }
}

function updateStats(tracks) {
  document.getElementById('totalSongs').textContent = `${tracks.length} canciones`;
  const artists = new Set(tracks.map(t=>t.artist).filter(Boolean));
  document.getElementById('totalArtists').textContent = `${artists.size} artistas`;
  const totalDuration = tracks.reduce((s,t)=>s+(t.duration||0),0);
  document.getElementById('totalDuration').textContent = `${Math.floor(totalDuration/60)} min`;
}

// ---------- Modal ----------
function showTrackDetails(track) {
  const modal = document.getElementById('musicModal');
  const content = document.getElementById('modalContent');
  const first = track.title ? track.title.charAt(0).toUpperCase() : '‚ô´';
  content.innerHTML = `
    <div class="modal-track-info"><div class="modal-album-art">${first}</div>
    <div class="modal-track-details">
      <div class="modal-track-title">${escapeHtml(track.title||'Sin t√≠tulo')}</div>
      <div class="modal-track-artist">${escapeHtml(track.artist||'Artista desconocido')}</div>
      <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
        <button class="modal-action-btn play" onclick='playTrackById(${track.id})'>‚ñ∂ Reproducir</button>
        <button class="modal-action-btn secondary" onclick='exportTrack(${track.id})'>‚¨áÔ∏è Guardar copia</button>
        <button class="modal-action-btn secondary" onclick='removeTrack(${track.id})'>üóëÔ∏è Eliminar</button>
      </div>
    </div></div>
    <div class="modal-stats">
      <div class="stat-item"><div class="stat-label">Duraci√≥n</div><div class="stat-value">${track.duration?formatTime(track.duration):'Desconocida'}</div></div>
      <div class="stat-item"><div class="stat-label">Tama√±o</div><div class="stat-value">${(track.fileSize? (track.fileSize/1024/1024).toFixed(2):'‚Äî')} MB</div></div>
      <div class="stat-item"><div class="stat-label">Formato</div><div class="stat-value">${(track.fileType||'‚Äî').toUpperCase()}</div></div>
      <div class="stat-item"><div class="stat-label">Agregado</div><div class="stat-value">${escapeHtml(track.dateAdded||'‚Äî')}</div></div>
    </div>
  `;
  modal.style.display = 'flex';
}
function closeModal(){ document.getElementById('musicModal').style.display='none'; }

// ---------- Play helpers ----------
async function playTrackById(id) {
  const all = await getAllTracksFromDB(); const t = all.find(x=>Number(x.id)===Number(id)); if (t) playTrack(t);
}

// ---------- Load music: main logic to guarantee local-first ----------
async function loadMusic() {
  try {
    if (!db) await openDB();

    // cargar token de usuario local o crear
    let token = await metaGet('userToken');
    if (!token) { token = uuidv4(); await metaPut('userToken', token); }

    // intentamos restaurar directoryHandle
    try {
      const saved = await metaGet('directoryHandle');
      if (saved && !directoryHandle) directoryHandle = saved;
    } catch (e) { directoryHandle = null; }

    // Si tenemos directory handle y permisos -> sincronizar exacto desde carpeta
    if (directoryHandle) {
      try {
        const perm = await directoryHandle.requestPermission({ mode: 'read' });
        if (perm === 'granted' || perm === 'prompt') {
          // sincronizar: limpiar DB y poblar desde carpeta
          const scanned = await clearAndPopulateFromDirectory();
          renderMusicGrid(scanned);
          updateStats(scanned);
          return;
        }
      } catch (err) { console.warn('perm check fail', err); }
    }

    // Si no hay carpeta o permiso, cargar desde DB (archivos previamente importados)
    const tracks = await getAllTracksFromDB();
    if (tracks.length === 0) {
      // forzar al usuario a elegir carpeta o a agregar archivos
      renderMusicGrid([]);
      showToast('Selecciona una carpeta local o agrega archivos para que la app funcione (local).');
      return;
    }

    renderMusicGrid(tracks);
    updateStats(tracks);
  } catch (err) {
    console.error('loadMusic error', err);
    showToast('Error cargando biblioteca. Revisa permisos y almacenamiento.');
  }
}

// ---------- UI Actions ----------
document.getElementById('addMusicBtn').addEventListener('click', async ()=>{
  if ('showDirectoryPicker' in window) {
    const r = confirm('¬øSeleccionar carpeta local para guardar autom√°ticamente? (recomendado)');
    if (r) { const ok = await requestDirectoryAccess(true); if (ok) { await clearAndPopulateFromDirectory(); showToast('Carpeta seleccionada y sincronizada'); await loadMusic(); return; } }
  }
  document.getElementById('fileInput').click();
});

document.getElementById('refreshBtn').addEventListener('click', loadMusic);

document.getElementById('sortBtn').addEventListener('click', async ()=>{
  const all = await getAllTracksFromDB(); all.sort((a,b)=> (a.title||'').localeCompare(b.title||'')); renderMusicGrid(all); });

document.getElementById('filterBtn').addEventListener('click', ()=>{ alert('Filtrado b√°sico: usa la b√∫squeda. (puedo a√±adir filtros avanzados si quieres)'); });

// Buscador en tiempo real
document.getElementById('searchInput').addEventListener('input', async (e)=>{
  const q = (e.target.value||'').toLowerCase().trim();
  if (!q) { const all = await getAllTracksFromDB(); renderMusicGrid(all); return; }
  const all = await getAllTracksFromDB();
  const filtered = all.filter(t=> (t.title||'').toLowerCase().includes(q) || (t.artist||'').toLowerCase().includes(q) || (t.fileName||'').toLowerCase().includes(q));
  renderMusicGrid(filtered);
});

// ---------- Init ----------
window.addEventListener('DOMContentLoaded', async ()=>{
  try { await openDB(); await loadMusic(); } catch (err) { console.error(err); showToast('Inicializaci√≥n fallida. Revisa consola.'); }
});

</script>
</body>
</html>
